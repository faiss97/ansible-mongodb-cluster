#!/bin/bash
# =============================================================================
# MongoDB Point-in-Time Restore Script
# =============================================================================
# Restores MongoDB to a specific point in time using snapshots and oplog.
# Generated by Ansible - Do not edit manually
# =============================================================================

set -euo pipefail

usage() {
    cat << EOF
Usage: $0 [OPTIONS]

Options:
    -t, --timestamp TIMESTAMP   Restore to this timestamp (ISO 8601 format)
    -s, --snapshot SNAPSHOT     Base snapshot to restore from
    -d, --database DATABASE     Restore specific database only
    -n, --dry-run              Show what would be done without executing
    -h, --help                 Show this help message

Examples:
    $0 -t "2024-01-15T10:30:00Z"
    $0 -s /var/backup/mongodb/snapshot_20240115 -t "2024-01-15T10:30:00Z"
    $0 -t "2024-01-15T10:30:00Z" -d myapp

EOF
    exit 1
}

# Configuration
PITR_DIR="{{ mongodb_pitr_directory }}"
BACKUP_DIR="{{ mongodb_backup_directory }}"
RESTORE_DIR="/tmp/mongodb-pitr-restore-$$"
LOG_FILE="${PITR_DIR}/logs/restore_$(date +%Y%m%d_%H%M%S).log"

# MongoDB connection
MONGO_HOST="localhost"
MONGO_PORT="{{ mongodb_port }}"
{% if mongodb_security_auth_enabled %}
AUTH_OPTS="--username {{ mongodb_admin_user }} --password {{ mongodb_admin_password }} --authenticationDatabase admin"
{% else %}
AUTH_OPTS=""
{% endif %}

# Parse arguments
TIMESTAMP=""
SNAPSHOT=""
DATABASE=""
DRY_RUN=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -t|--timestamp)
            TIMESTAMP="$2"
            shift 2
            ;;
        -s|--snapshot)
            SNAPSHOT="$2"
            shift 2
            ;;
        -d|--database)
            DATABASE="$2"
            shift 2
            ;;
        -n|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -h|--help)
            usage
            ;;
        *)
            echo "Unknown option: $1"
            usage
            ;;
    esac
done

if [ -z "${TIMESTAMP}" ]; then
    echo "Error: Timestamp is required"
    usage
fi

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "${LOG_FILE}"
}

error_exit() {
    log "ERROR: $1"
    exit 1
}

# Convert timestamp to MongoDB Timestamp
RESTORE_TS=$(date -d "${TIMESTAMP}" +%s)
log "Target restore timestamp: ${TIMESTAMP} (${RESTORE_TS})"

# Find appropriate snapshot
if [ -z "${SNAPSHOT}" ]; then
    log "Finding latest snapshot before ${TIMESTAMP}..."
    SNAPSHOT=$(ls -t ${PITR_DIR}/snapshots/*.tar.gz 2>/dev/null | while read f; do
        SNAP_TS=$(stat -c %Y "$f")
        if [ ${SNAP_TS} -le ${RESTORE_TS} ]; then
            echo "$f"
            break
        fi
    done)
fi

if [ -z "${SNAPSHOT}" ] || [ ! -f "${SNAPSHOT}" ]; then
    error_exit "No suitable snapshot found for timestamp ${TIMESTAMP}"
fi

log "Using snapshot: ${SNAPSHOT}"

# Find oplog files to apply
log "Finding oplog files to apply..."
OPLOG_FILES=$(ls -t ${PITR_DIR}/oplog/*.bson 2>/dev/null | while read f; do
    FILE_TS=$(stat -c %Y "$f")
    SNAP_TS=$(stat -c %Y "${SNAPSHOT}")
    if [ ${FILE_TS} -ge ${SNAP_TS} ] && [ ${FILE_TS} -le ${RESTORE_TS} ]; then
        echo "$f"
    fi
done | tac)

log "Oplog files to apply: $(echo ${OPLOG_FILES} | wc -w)"

if [ "${DRY_RUN}" = true ]; then
    log "DRY RUN - Would perform the following actions:"
    log "  1. Stop MongoDB"
    log "  2. Restore snapshot: ${SNAPSHOT}"
    log "  3. Apply $(echo ${OPLOG_FILES} | wc -w) oplog files"
    log "  4. Start MongoDB"
    exit 0
fi

# Confirmation
echo ""
echo "WARNING: This will restore MongoDB to ${TIMESTAMP}"
echo "All data after this timestamp will be LOST!"
echo ""
read -p "Are you sure you want to continue? (yes/no): " CONFIRM

if [ "${CONFIRM}" != "yes" ]; then
    log "Restore cancelled by user"
    exit 0
fi

# Create restore directory
mkdir -p "${RESTORE_DIR}"

# Stop MongoDB
log "Stopping MongoDB..."
systemctl stop {{ mongodb_service_name }}

# Backup current data (safety)
log "Creating safety backup of current data..."
SAFETY_BACKUP="/tmp/mongodb-safety-backup-$(date +%Y%m%d_%H%M%S)"
mv {{ mongodb_data_directory }} "${SAFETY_BACKUP}"
mkdir -p {{ mongodb_data_directory }}
chown {{ mongodb_user }}:{{ mongodb_group }} {{ mongodb_data_directory }}

# Extract snapshot
log "Extracting snapshot..."
tar -xzf "${SNAPSHOT}" -C "${RESTORE_DIR}"

# Restore snapshot
log "Restoring snapshot..."
SNAPSHOT_DIR=$(ls -d ${RESTORE_DIR}/*/2>/dev/null | head -1)
mongorestore \
    --host ${MONGO_HOST} --port ${MONGO_PORT} \
    ${AUTH_OPTS} \
    --drop \
    ${DATABASE:+--db ${DATABASE}} \
    "${SNAPSHOT_DIR}"

# Start MongoDB in standalone mode for oplog replay
log "Starting MongoDB in standalone mode..."
mongod --config {{ mongodb_config_file }} --replSet "" --fork

sleep 10

# Apply oplog entries
log "Applying oplog entries..."
for OPLOG_FILE in ${OPLOG_FILES}; do
    log "Applying: ${OPLOG_FILE}"
    mongorestore \
        --host ${MONGO_HOST} --port ${MONGO_PORT} \
        ${AUTH_OPTS} \
        --oplogReplay \
        --oplogLimit "${RESTORE_TS}:0" \
        "${OPLOG_FILE}"
done

# Stop standalone MongoDB
log "Stopping standalone MongoDB..."
mongosh --host ${MONGO_HOST} --port ${MONGO_PORT} ${AUTH_OPTS} \
    --eval "db.adminCommand({shutdown: 1})" || true

# Start MongoDB normally
log "Starting MongoDB with replica set configuration..."
systemctl start {{ mongodb_service_name }}

# Wait for MongoDB to be ready
sleep 30

# Verify restoration
log "Verifying restoration..."
mongosh --host ${MONGO_HOST} --port ${MONGO_PORT} ${AUTH_OPTS} \
    --eval "db.adminCommand('ping')" --quiet

log "Point-in-time restore completed successfully!"
log "Data restored to: ${TIMESTAMP}"
log "Safety backup available at: ${SAFETY_BACKUP}"

# Cleanup
rm -rf "${RESTORE_DIR}"

exit 0
