#!/bin/bash
# =============================================================================
# MongoDB Health Monitor Script
# =============================================================================
# Monitors MongoDB health and sends alerts when issues are detected.
# Generated by Ansible - Do not edit manually
# =============================================================================

set -euo pipefail

source /opt/mongodb-alerting/alerting.conf

LOG_FILE="/opt/mongodb-alerting/logs/health-monitor.log"
STATE_DIR="/opt/mongodb-alerting/state"

{% if mongodb_security_auth_enabled %}
AUTH_OPTS="--username ${MONGO_USER} --password ${MONGO_PASS} --authenticationDatabase admin"
{% else %}
AUTH_OPTS=""
{% endif %}

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "${LOG_FILE}"
}

send_alert() {
    local severity=$1
    local message=$2
    local details=$3
    /opt/mongodb-alerting/scripts/mongodb-alert.sh "${severity}" "${message}" "${details}"
}

# State management for alert deduplication
get_state() {
    local key=$1
    cat "${STATE_DIR}/${key}" 2>/dev/null || echo ""
}

set_state() {
    local key=$1
    local value=$2
    echo "${value}" > "${STATE_DIR}/${key}"
}

clear_state() {
    local key=$1
    rm -f "${STATE_DIR}/${key}"
}

# Check MongoDB connectivity
check_connectivity() {
    log "Checking MongoDB connectivity..."
    
    if ! mongosh --host ${MONGO_HOST} --port ${MONGO_PORT} ${AUTH_OPTS} \
        --eval "db.adminCommand('ping')" --quiet > /dev/null 2>&1; then
        
        if [ "$(get_state mongodb_down)" != "1" ]; then
            send_alert "critical" "MongoDB is unreachable" "Cannot connect to MongoDB on ${MONGO_HOST}:${MONGO_PORT}"
            set_state "mongodb_down" "1"
        fi
        return 1
    else
        if [ "$(get_state mongodb_down)" = "1" ]; then
            send_alert "info" "MongoDB is back online" "Connection restored to ${MONGO_HOST}:${MONGO_PORT}"
            clear_state "mongodb_down"
        fi
        return 0
    fi
}

# Check replica set status
check_replicaset() {
    log "Checking replica set status..."
    
    local rs_status=$(mongosh --host ${MONGO_HOST} --port ${MONGO_PORT} ${AUTH_OPTS} \
        --eval "JSON.stringify(rs.status())" --quiet 2>/dev/null)
    
    if [ -z "${rs_status}" ]; then
        log "Failed to get replica set status"
        return 1
    fi
    
    # Check for primary
    local has_primary=$(echo "${rs_status}" | jq -r '.members[] | select(.stateStr == "PRIMARY") | .name' | head -1)
    
    if [ -z "${has_primary}" ]; then
        if [ "$(get_state no_primary)" != "1" ]; then
            send_alert "critical" "No PRIMARY in replica set" "Replica set has no primary node"
            set_state "no_primary" "1"
        fi
    else
        if [ "$(get_state no_primary)" = "1" ]; then
            send_alert "info" "PRIMARY elected" "New primary: ${has_primary}"
            clear_state "no_primary"
        fi
    fi
    
    # Check unhealthy members
    local unhealthy=$(echo "${rs_status}" | jq -r '[.members[] | select(.health != 1)] | length')
    
    if [ "${unhealthy}" -gt 0 ]; then
        local unhealthy_names=$(echo "${rs_status}" | jq -r '.members[] | select(.health != 1) | .name' | tr '\n' ', ')
        if [ "$(get_state unhealthy_members)" != "${unhealthy}" ]; then
            send_alert "warning" "Unhealthy replica set members" "Unhealthy nodes: ${unhealthy_names}"
            set_state "unhealthy_members" "${unhealthy}"
        fi
    else
        if [ -n "$(get_state unhealthy_members)" ]; then
            send_alert "info" "All replica set members healthy" "All nodes are now healthy"
            clear_state "unhealthy_members"
        fi
    fi
}

# Check replication lag
check_replication_lag() {
    log "Checking replication lag..."
    
    local lag=$(mongosh --host ${MONGO_HOST} --port ${MONGO_PORT} ${AUTH_OPTS} --eval '
        var status = rs.status();
        var primary = status.members.find(m => m.stateStr === "PRIMARY");
        var maxLag = 0;
        status.members.filter(m => m.stateStr === "SECONDARY").forEach(s => {
            var lag = (primary.optimeDate - s.optimeDate) / 1000;
            if (lag > maxLag) maxLag = lag;
        });
        print(Math.round(maxLag));
    ' --quiet 2>/dev/null || echo "0")
    
    log "Current replication lag: ${lag}s"
    
    if [ "${lag}" -ge "${REPLICATION_LAG_CRITICAL}" ]; then
        if [ "$(get_state repl_lag_critical)" != "1" ]; then
            send_alert "critical" "Critical replication lag" "Replication lag is ${lag} seconds (threshold: ${REPLICATION_LAG_CRITICAL}s)"
            set_state "repl_lag_critical" "1"
            clear_state "repl_lag_warning"
        fi
    elif [ "${lag}" -ge "${REPLICATION_LAG_WARNING}" ]; then
        if [ "$(get_state repl_lag_warning)" != "1" ]; then
            send_alert "warning" "High replication lag" "Replication lag is ${lag} seconds (threshold: ${REPLICATION_LAG_WARNING}s)"
            set_state "repl_lag_warning" "1"
        fi
        clear_state "repl_lag_critical"
    else
        if [ "$(get_state repl_lag_critical)" = "1" ] || [ "$(get_state repl_lag_warning)" = "1" ]; then
            send_alert "info" "Replication lag recovered" "Replication lag is now ${lag} seconds"
            clear_state "repl_lag_critical"
            clear_state "repl_lag_warning"
        fi
    fi
}

# Check disk usage
check_disk_usage() {
    log "Checking disk usage..."
    
    local usage=$(df -h {{ mongodb_data_directory }} | tail -1 | awk '{print $5}' | sed 's/%//')
    
    log "Current disk usage: ${usage}%"
    
    if [ "${usage}" -ge "${DISK_USAGE_CRITICAL}" ]; then
        if [ "$(get_state disk_critical)" != "1" ]; then
            send_alert "critical" "Critical disk space" "Disk usage is ${usage}% (threshold: ${DISK_USAGE_CRITICAL}%)"
            set_state "disk_critical" "1"
            clear_state "disk_warning"
        fi
    elif [ "${usage}" -ge "${DISK_USAGE_WARNING}" ]; then
        if [ "$(get_state disk_warning)" != "1" ]; then
            send_alert "warning" "Low disk space" "Disk usage is ${usage}% (threshold: ${DISK_USAGE_WARNING}%)"
            set_state "disk_warning" "1"
        fi
        clear_state "disk_critical"
    else
        if [ "$(get_state disk_critical)" = "1" ] || [ "$(get_state disk_warning)" = "1" ]; then
            send_alert "info" "Disk space recovered" "Disk usage is now ${usage}%"
            clear_state "disk_critical"
            clear_state "disk_warning"
        fi
    fi
}

# Check connections
check_connections() {
    log "Checking connection usage..."
    
    local conn_info=$(mongosh --host ${MONGO_HOST} --port ${MONGO_PORT} ${AUTH_OPTS} \
        --eval "JSON.stringify(db.serverStatus().connections)" --quiet 2>/dev/null)
    
    local current=$(echo "${conn_info}" | jq -r '.current')
    local available=$(echo "${conn_info}" | jq -r '.available')
    local total=$((current + available))
    local pct=$((current * 100 / total))
    
    log "Connection usage: ${current}/${total} (${pct}%)"
    
    if [ "${pct}" -ge "${CONNECTION_CRITICAL}" ]; then
        if [ "$(get_state conn_critical)" != "1" ]; then
            send_alert "critical" "Critical connection usage" "Using ${current}/${total} connections (${pct}%)"
            set_state "conn_critical" "1"
        fi
    elif [ "${pct}" -ge "${CONNECTION_WARNING}" ]; then
        if [ "$(get_state conn_warning)" != "1" ]; then
            send_alert "warning" "High connection usage" "Using ${current}/${total} connections (${pct}%)"
            set_state "conn_warning" "1"
        fi
        clear_state "conn_critical"
    else
        clear_state "conn_critical"
        clear_state "conn_warning"
    fi
}

# Main monitoring loop
main() {
    log "Starting health monitor check..."
    
    mkdir -p "${STATE_DIR}"
    
    if check_connectivity; then
{% if mongodb_deployment_mode == 'replicaset' %}
        check_replicaset
        check_replication_lag
{% endif %}
        check_disk_usage
        check_connections
    fi
    
    log "Health monitor check completed"
}

main "$@"
